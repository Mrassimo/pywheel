<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyWheel Manager</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-light: #f3f4f6;
            --border: #e5e7eb;
            --text: #1f2937;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #fafafa;
            --card-bg: #ffffff;
        }
        
        [data-theme="dark"] {
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --bg-light: #374151;
            --border: #4b5563;
            --text: #e5e7eb;
            --background: #1f2937;
            --card-bg: #111827;
            --success: #059669;
            --warning: #d97706;
            --error: #dc2626;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.5;
            color: var(--text);
            margin: 0;
            padding: 0;
            background: var(--background);
            transition: background 0.3s, color 0.3s;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        .header h1 {
            margin: 0;
            font-size: 1.8rem;
        }
        .theme-toggle {
            margin-right: 1rem;
            cursor: pointer;
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
        }
        .card {
            background: var(--card-bg);
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        input, select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 1rem;
            background-color: var(--bg-light);
            color: var(--text);
        }
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover {
            background: var(--primary-hover);
        }
        .btn-secondary {
            background: var(--bg-light);
            color: var(--text);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover {
            background: var(--bg-light);
            opacity: 0.9;
        }
        .buttons-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        .inputs-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .inputs-row .form-group {
            flex: 1;
            min-width: 200px;
        }
        .package-list {
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            max-height: 300px;
            overflow-y: auto;
        }
        .package-item {
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .package-item:last-child {
            border-bottom: none;
        }
        .package-name {
            font-weight: 500;
        }
        .package-version {
            color: var(--text);
            opacity: 0.7;
            font-size: 0.9rem;
        }
        .tab-container {
            margin-bottom: 1rem;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }
        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
        }
        .tab.active {
            border-bottom: 2px solid var(--primary);
            font-weight: 500;
        }
        .tab-content {
            padding: 1rem 0;
        }
        .badge {
            background: var(--bg-light);
            padding: 0.25rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.8rem;
        }
        .badge-primary {
            background: var(--primary);
            color: white;
        }
        .badge-success {
            background: var(--success);
            color: white;
        }
        .badge-warning {
            background: var(--warning);
            color: white;
        }
        .progress-container {
            margin: 1rem 0;
            display: none;
        }
        .progress-bar {
            height: 0.5rem;
            background: var(--bg-light);
            border-radius: 0.25rem;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }
        .actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        .dependency-tree {
            margin-top: 1rem;
        }
        .tree-item {
            margin-left: 1.5rem;
        }
        .tree-item-root {
            margin-left: 0;
            font-weight: 500;
        }
        .download-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        .download-links {
            margin-top: 1rem;
        }
        .download-links table {
            width: 100%;
            border-collapse: collapse;
        }
        .download-links table th,
        .download-links table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .clipboard-area {
            background: var(--bg-light);
            padding: 1rem;
            border-radius: 0.25rem;
            margin-top: 1rem;
            white-space: pre-wrap;
            font-family: monospace;
        }
        .status {
            padding: 0.5rem;
            margin-top: 1rem;
            border-radius: 0.25rem;
        }
        .status-success {
            background: #d1fae5;
            color: #065f46;
        }
        [data-theme="dark"] .status-success {
            background: #065f46;
            color: #d1fae5;
        }
        .status-error {
            background: #fee2e2;
            color: #b91c1c;
        }
        [data-theme="dark"] .status-error {
            background: #b91c1c;
            color: #fee2e2;
        }
        .status-info {
            background: #dbeafe;
            color: #1e40af;
        }
        [data-theme="dark"] .status-info {
            background: #1e40af;
            color: #dbeafe;
        }
        .autocomplete-container {
            position: relative;
        }
        .autocomplete-list {
            position: absolute;
            width: 100%;
            background-color: var(--card-bg);
            border: 1px solid var(--border);
            border-top: none;
            z-index: 99;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 0 0 0.25rem 0.25rem;
            display: none;
        }
        .autocomplete-item {
            padding: 0.5rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        .autocomplete-item:hover {
            background-color: var(--bg-light);
        }
        .input-group {
            display: flex;
            margin-bottom: 1rem;
        }
        .input-group-text {
            padding: 0.5rem;
            background-color: var(--bg-light);
            border: 1px solid var(--border);
            border-right: none;
            border-radius: 0.25rem 0 0 0.25rem;
            color: var(--text);
        }
        .input-group input {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
        .settings-toggle {
            margin-top: 1rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .settings-toggle:after {
            content: "▼";
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }
        .settings-toggle.expanded:after {
            content: "▲";
        }
        .advanced-settings {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            display: none;
        }
        .advanced-settings.visible {
            display: block;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 0.5rem;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.5rem;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .modal-header h3 {
            margin: 0;
        }
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text);
        }
        .download-status {
            font-size: 0.9rem;
            margin-left: 0.5rem;
            display: none;
        }
        .download-status.success {
            color: var(--success);
        }
        .download-status.error {
            color: var(--error);
        }
        .path-input {
            display: flex;
            align-items: center;
        }
        .path-input input {
            flex: 1;
            margin-right: 0.5rem;
        }
        .path-input button {
            white-space: nowrap;
        }
        .help-text {
            font-size: 0.8rem;
            color: var(--text);
            opacity: 0.8;
            margin-top: 0.25rem;
        }
        .info-box {
            background-color: var(--bg-light);
            padding: 0.75rem;
            border-radius: 0.25rem;
            margin: 1rem 0;
            border-left: 3px solid var(--primary);
        }
        @media (max-width: 768px) {
            .inputs-row {
                flex-direction: column;
            }
            .inputs-row .form-group {
                width: 100%;
            }
            .buttons-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PyWheel Manager</h1>
            <div style="display: flex; align-items: center;">
                <button id="themeToggleBtn" class="theme-toggle" aria-label="Toggle dark mode">
                    🌙
                </button>
            </div>
        </div>

        <div class="card">
            <h2>Package Configuration</h2>
            <form id="packageForm">
                <div class="inputs-row">
                    <div class="form-group">
                        <label for="packageSource">Package Source</label>
                        <select id="packageSource">
                            <option value="name">Package Name</option>
                            <option value="url">PyPI URL</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="installDir">Installation Directory</label>
                        <div class="path-input">
                            <input type="text" id="installDir" value="wheels" placeholder="Directory for wheel files">
                            <button type="button" id="browseInstallDir" class="btn btn-secondary">Browse</button>
                        </div>
                        <div class="help-text">Directory where wheels will be downloaded</div>
                    </div>
                </div>

                <div id="packageNameContainer" class="inputs-row">
                    <div class="form-group autocomplete-container">
                        <label for="packageName">Package Name</label>
                        <input type="text" id="packageName" placeholder="e.g. snowflake-connector-python" required>
                        <div id="autocompleteList" class="autocomplete-list"></div>
                    </div>
                    <div class="form-group">
                        <label for="pythonVersion">Python Version</label>
                        <select id="pythonVersion">
                            <option value="3.12">Python 3.12</option>
                            <option value="3.11">Python 3.11</option>
                            <option value="3.10">Python 3.10</option>
                            <option value="3.9">Python 3.9</option>
                            <option value="3.8">Python 3.8</option>
                            <option value="3.7">Python 3.7</option>
                        </select>
                    </div>
                </div>

                <div id="packageUrlContainer" class="inputs-row" style="display: none;">
                    <div class="form-group">
                        <label for="packageUrl">PyPI URL</label>
                        <input type="url" id="packageUrl" placeholder="e.g. https://pypi.org/project/snowflake-connector-python/">
                    </div>
                    <div class="form-group">
                        <label for="pythonVersionUrl">Python Version</label>
                        <select id="pythonVersionUrl">
                            <option value="3.12">Python 3.12</option>
                            <option value="3.11">Python 3.11</option>
                            <option value="3.10">Python 3.10</option>
                            <option value="3.9">Python 3.9</option>
                            <option value="3.8">Python 3.8</option>
                            <option value="3.7">Python 3.7</option>
                        </select>
                    </div>
                </div>

                <div class="settings-toggle" id="advancedSettingsToggle">Advanced Settings</div>
                <div class="advanced-settings" id="advancedSettings">
                    <div class="inputs-row">
                        <div class="form-group">
                            <label for="platform">Platform</label>
                            <select id="platform">
                                <option value="win">Windows</option>
                                <option value="linux">Linux</option>
                                <option value="macosx">macOS</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="architecture">Architecture</label>
                            <select id="architecture">
                                <option value="x86_64">x86_64 (AMD64)</option>
                                <option value="arm64">ARM64 (AArch64)</option>
                                <option value="i686">i686 (x86)</option>
                                <option value="ppc64le">PowerPC 64-bit Little Endian</option>
                                <option value="s390x">s390x (IBM Z)</option>
                            </select>
                        </div>
                    </div>
                    <div class="inputs-row">
                        <div class="form-group">
                            <label for="maxDependencyDepth">Max Dependency Depth</label>
                            <input type="number" id="maxDependencyDepth" value="10" min="1" max="100">
                            <div class="help-text">Limit how deep to search for dependencies (1-100)</div>
                        </div>
                        <div class="form-group">
                            <label for="maxPackageCount">Max Package Count</label>
                            <input type="number" id="maxPackageCount" value="100" min="1" max="1000">
                            <div class="help-text">Maximum number of packages to analyze (1-1000)</div>
                        </div>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="sequentialDownload" checked>
                        <label for="sequentialDownload">Use sequential download (more reliable)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="createDirIfMissing" checked>
                        <label for="createDirIfMissing">Create installation directory if it doesn't exist</label>
                    </div>
                </div>

                <button type="submit" class="btn" style="margin-top: 1rem;">Analyse Dependencies</button>
            </form>

            <div id="progressContainer" class="progress-container">
                <div class="progress-bar">
                    <div id="progress" class="progress"></div>
                </div>
                <div id="progressText">Analysing dependencies...</div>
            </div>

            <div id="status" class="status" style="display: none;"></div>
        </div>

        <div id="resultsContainer" style="display: none;">
            <div class="tab-container">
                <div class="tabs">
                    <div class="tab active" data-tab="dependencies">Dependencies</div>
                    <div class="tab" data-tab="downloads">Downloads</div>
                    <div class="tab" data-tab="install">Installation</div>
                </div>
                <div class="tab-content">
                    <div id="dependenciesTab" class="tab-pane active">
                        <h3>Dependency Tree</h3>
                        <div id="dependencyTree" class="dependency-tree"></div>
                        <div class="summary">
                            <p>Total packages: <span id="totalPackages">0</span></p>
                        </div>
                    </div>
                    <div id="downloadsTab" class="tab-pane" style="display: none;">
                        <h3>Download Files</h3>
                        <div class="info-box">
                            Directory: <span id="currentInstallPath">wheels</span>
                            <button id="changePathBtn" class="btn btn-secondary" style="float: right; margin-top: -5px;">Change</button>
                        </div>
                        <button id="downloadBtn" class="btn">Download All Files</button>
                        <div id="downloadLinks" class="download-links"></div>
                    </div>
                    <div id="installTab" class="tab-pane" style="display: none;">
                        <h3>Installation Instructions</h3>
                        <p>After downloading all files to the installation directory, run the following command:</p>
                        <div class="clipboard-area" id="installCommand">pip install --no-index --find-links=./wheels package-name</div>
                        <button id="copyCommandBtn" class="btn">Copy Command</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Path selector modal -->
    <div id="pathModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select Installation Directory</h3>
                <button class="close-modal" id="closePathModal">&times;</button>
            </div>
            <p>Enter the directory path where you want to install the wheel files:</p>
            <div class="form-group">
                <input type="text" id="customInstallPath" placeholder="e.g., wheels or C:\Python\Libs\wheels">
            </div>
            <div class="buttons-row">
                <button id="confirmPathBtn" class="btn">Set Directory</button>
                <button id="cancelPathBtn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Main application logic
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize application state
            const state = {
                packageName: '',
                packageUrl: '',
                pythonVersion: '',
                platform: '',
                architecture: '',
                dependencies: new Map(),
                processed: new Set(),
                processing: new Set(),
                pendingDependencies: [], // Queue for packages to process (non-recursive approach)
                downloadUrls: [],
                maxDependencyDepth: 10,
                maxPackageCount: 100,
                currentDepth: 0,
                cancelled: false,
                pythonVersionCompatible: true,
                installDir: 'wheels',
                sequentialDownload: true,
                createDirIfMissing: true,
                downloadingFiles: false,
                processingComplete: false,
                popularPackages: [
                    'numpy', 'pandas', 'matplotlib', 'scikit-learn', 'tensorflow', 'torch', 'django',
                    'flask', 'requests', 'beautifulsoup4', 'scipy', 'pillow', 'pytest', 'selenium',
                    'fastapi', 'opencv-python', 'sqlalchemy', 'boto3', 'nltk', 'streamlit',
                    'scrapy', 'transformers', 'jupyter', 'dash', 'seaborn', 'keras', 'pygame',
                    'psutil', 'scikit-image', 'statsmodels', 'snowflake-connector-python', 'pyspark'
                ]
            };

            // DOM elements
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            const packageForm = document.getElementById('packageForm');
            const packageSource = document.getElementById('packageSource');
            const packageNameContainer = document.getElementById('packageNameContainer');
            const packageUrlContainer = document.getElementById('packageUrlContainer');
            const packageNameInput = document.getElementById('packageName');
            const packageUrlInput = document.getElementById('packageUrl');
            const installDirInput = document.getElementById('installDir');
            const browseInstallDirBtn = document.getElementById('browseInstallDir');
            const sequentialDownloadCheck = document.getElementById('sequentialDownload');
            const createDirIfMissingCheck = document.getElementById('createDirIfMissing');
            const autocompleteList = document.getElementById('autocompleteList');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progress');
            const progressText = document.getElementById('progressText');
            const resultsContainer = document.getElementById('resultsContainer');
            const dependencyTree = document.getElementById('dependencyTree');
            const downloadLinks = document.getElementById('downloadLinks');
            const totalPackages = document.getElementById('totalPackages');
            const installCommand = document.getElementById('installCommand');
            const copyCommandBtn = document.getElementById('copyCommandBtn');
            const statusEl = document.getElementById('status');
            const downloadBtn = document.getElementById('downloadBtn');
            const currentInstallPath = document.getElementById('currentInstallPath');
            const changePathBtn = document.getElementById('changePathBtn');
            const advancedSettingsToggle = document.getElementById('advancedSettingsToggle');
            const advancedSettings = document.getElementById('advancedSettings');
            const maxDependencyDepthInput = document.getElementById('maxDependencyDepth');
            const maxPackageCountInput = document.getElementById('maxPackageCount');
            
            // Path modal elements
            const pathModal = document.getElementById('pathModal');
            const customInstallPathInput = document.getElementById('customInstallPath');
            const confirmPathBtn = document.getElementById('confirmPathBtn');
            const cancelPathBtn = document.getElementById('cancelPathBtn');
            const closePathModalBtn = document.getElementById('closePathModal');

            // Initialize theme based on user preference
            initTheme();

            // Update installation directory in UI
            function updateInstallDirUI() {
                currentInstallPath.textContent = state.installDir;
                updateInstallationCommand();
            }

            // Theme toggle functionality
            themeToggleBtn.addEventListener('click', function() {
                toggleTheme();
            });

            // Advanced settings toggle
            advancedSettingsToggle.addEventListener('click', function() {
                this.classList.toggle('expanded');
                advancedSettings.classList.toggle('visible');
            });

            // Source type toggle
            packageSource.addEventListener('change', function(e) {
                const selectedValue = e.target.value;
                if (selectedValue === 'name') {
                    packageNameContainer.style.display = 'flex';
                    packageUrlContainer.style.display = 'none';
                } else {
                    packageNameContainer.style.display = 'none';
                    packageUrlContainer.style.display = 'flex';
                }
            });

            // Install directory input change
            installDirInput.addEventListener('input', function() {
                state.installDir = this.value.trim() || 'wheels';
                updateInstallDirUI();
            });

            // Sequential download checkbox
            sequentialDownloadCheck.addEventListener('change', function() {
                state.sequentialDownload = this.checked;
            });

            // Create directory checkbox
            createDirIfMissingCheck.addEventListener('change', function() {
                state.createDirIfMissing = this.checked;
            });

            // Browse installation directory button
            browseInstallDirBtn.addEventListener('click', function() {
                showPathModal();
            });

            // Change path button
            changePathBtn.addEventListener('click', function() {
                showPathModal();
            });

            // Path modal functions
            function showPathModal() {
                customInstallPathInput.value = state.installDir;
                pathModal.style.display = 'flex';
            }

            function hidePathModal() {
                pathModal.style.display = 'none';
            }

            // Close path modal buttons
            closePathModalBtn.addEventListener('click', hidePathModal);
            cancelPathBtn.addEventListener('click', hidePathModal);

            // Confirm path button
            confirmPathBtn.addEventListener('click', function() {
                const newPath = customInstallPathInput.value.trim();
                if (newPath) {
                    state.installDir = newPath;
                    installDirInput.value = newPath;
                    updateInstallDirUI();
                    showStatus(`Installation directory updated to: ${newPath}`, 'success');
                    hidePathModal();
                } else {
                    showStatus('Please enter a valid directory path', 'error');
                }
            });

            // Download button
            downloadBtn.addEventListener('click', function() {
                if (state.downloadingFiles) {
                    showStatus('Download already in progress', 'info');
                    return;
                }
                
                if (state.downloadUrls.length === 0) {
                    showStatus('No files to download', 'error');
                    return;
                }
                
                downloadFiles();
            });

            // Autocomplete for package name
            packageNameInput.addEventListener('input', function() {
                const inputVal = this.value.toLowerCase();
                autocompleteList.innerHTML = '';
                
                if (inputVal.length < 2) {
                    autocompleteList.style.display = 'none';
                    return;
                }
                
                // Filter popular packages
                const matchingPackages = state.popularPackages.filter(pkg => 
                    pkg.toLowerCase().includes(inputVal)
                );
                
                if (matchingPackages.length > 0) {
                    autocompleteList.style.display = 'block';
                    matchingPackages.forEach(pkg => {
                        const item = document.createElement('div');
                        item.className = 'autocomplete-item';
                        item.textContent = pkg;
                        item.addEventListener('click', function() {
                            packageNameInput.value = pkg;
                            autocompleteList.style.display = 'none';
                        });
                        autocompleteList.appendChild(item);
                    });
                } else {
                    autocompleteList.style.display = 'none';
                }
            });
            
            // Hide autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (e.target !== packageNameInput) {
                    autocompleteList.style.display = 'none';
                }
            });

            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Hide all tabs
                    document.querySelectorAll('.tab-pane').forEach(pane => {
                        pane.style.display = 'none';
                    });
                    document.querySelectorAll('.tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    
                    // Show selected tab
                    const tabName = tab.dataset.tab;
                    document.getElementById(`${tabName}Tab`).style.display = 'block';
                    tab.classList.add('active');
                });
            });

            // Form submission
            packageForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                // Check if download is in progress
                if (state.downloadingFiles) {
                    showStatus('Download in progress, please wait...', 'info');
                    return;
                }
                
                // Reset state
                state.dependencies = new Map();
                state.processed = new Set();
                state.processing = new Set();
                state.pendingDependencies = [];
                state.downloadUrls = [];
                state.cancelled = false;
                state.pythonVersionCompatible = true;
                state.currentDepth = 0;
                state.processingComplete = false;
                
                // Get form values
                const sourceType = packageSource.value;
                if (sourceType === 'name') {
                    state.packageName = packageNameInput.value.trim();
                    state.pythonVersion = document.getElementById('pythonVersion').value;
                } else {
                    // Extract package name from URL
                    const url = packageUrlInput.value.trim();
                    const urlMatch = url.match(/\/project\/([^\/]+)/);
                    if (urlMatch && urlMatch[1]) {
                        state.packageName = urlMatch[1];
                    } else {
                        showStatus('Invalid PyPI URL. Format should be: https://pypi.org/project/package-name/', 'error');
                        return;
                    }
                    state.pythonVersion = document.getElementById('pythonVersionUrl').value;
                }
                
                state.platform = document.getElementById('platform').value;
                state.architecture = document.getElementById('architecture').value;
                state.maxDependencyDepth = parseInt(maxDependencyDepthInput.value) || 10;
                state.maxPackageCount = parseInt(maxPackageCountInput.value) || 100;
                state.installDir = installDirInput.value.trim() || 'wheels';
                state.sequentialDownload = sequentialDownloadCheck.checked;
                state.createDirIfMissing = createDirIfMissingCheck.checked;
                
                if (!state.packageName) {
                    showStatus('Please enter a package name', 'error');
                    return;
                }
                
                // Show progress
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressText.textContent = 'Analysing dependencies...';
                statusEl.style.display = 'none';
                resultsContainer.style.display = 'none';
                
                // Start analysis with new iterative approach
                analysePackage(state.packageName, null, 0)
                    .then(() => {
                        // Now process the queue until empty
                        return processRemainingDependencies();
                    })
                    .then(() => {
                        state.processingComplete = true;
                        
                        if (state.cancelled) {
                            progressContainer.style.display = 'none';
                            return;
                        }
                        
                        if (state.processed.size === 0) {
                            progressContainer.style.display = 'none';
                            showStatus(`No compatible packages found for ${state.packageName} with Python ${state.pythonVersion}`, 'error');
                            return;
                        }
                        
                        displayResults();
                        progressContainer.style.display = 'none';
                        resultsContainer.style.display = 'block';
                        showStatus('Analysis complete! Review the tabs below.', 'success');
                    })
                    .catch(error => {
                        progressContainer.style.display = 'none';
                        showStatus(`Error: ${error.message}`, 'error');
                        console.error(error);
                    });
            });

            // Copy installation command
            copyCommandBtn.addEventListener('click', function() {
                const command = installCommand.textContent;
                navigator.clipboard.writeText(command)
                    .then(() => {
                        showStatus('Command copied to clipboard!', 'success');
                    })
                    .catch(err => {
                        showStatus('Failed to copy command', 'error');
                    });
            });

            // Auto-save configuration to localStorage when values change
            function saveCurrentConfig() {
                const config = {
                    packageName: packageNameInput.value,
                    packageUrl: packageUrlInput.value,
                    pythonVersion: document.getElementById('pythonVersion').value,
                    pythonVersionUrl: document.getElementById('pythonVersionUrl').value,
                    platform: document.getElementById('platform').value,
                    architecture: document.getElementById('architecture').value,
                    packageSource: packageSource.value,
                    maxDependencyDepth: maxDependencyDepthInput.value,
                    maxPackageCount: maxPackageCountInput.value,
                    installDir: installDirInput.value,
                    sequentialDownload: sequentialDownloadCheck.checked,
                    createDirIfMissing: createDirIfMissingCheck.checked,
                    theme: document.documentElement.getAttribute('data-theme') || 'light'
                };
                
                try {
                    localStorage.setItem('pyWheelManagerConfig', JSON.stringify(config));
                } catch (error) {
                    console.error('Failed to save configuration', error);
                }
            }
            
            // Auto-save on change
            [packageNameInput, packageUrlInput, installDirInput, 
             sequentialDownloadCheck, createDirIfMissingCheck,
             maxDependencyDepthInput, maxPackageCountInput].forEach(el => {
                el.addEventListener('change', saveCurrentConfig);
            });
            
            // Load configuration on startup
            try {
                const config = JSON.parse(localStorage.getItem('pyWheelManagerConfig'));
                if (config) {
                    packageNameInput.value = config.packageName || '';
                    packageUrlInput.value = config.packageUrl || '';
                    document.getElementById('pythonVersion').value = config.pythonVersion || '3.9';
                    document.getElementById('pythonVersionUrl').value = config.pythonVersionUrl || '3.9';
                    document.getElementById('platform').value = config.platform || detectPlatform();
                    document.getElementById('architecture').value = config.architecture || detectArchitecture();
                    maxDependencyDepthInput.value = config.maxDependencyDepth || 10;
                    maxPackageCountInput.value = config.maxPackageCount || 100;
                    installDirInput.value = config.installDir || 'wheels';
                    sequentialDownloadCheck.checked = config.sequentialDownload !== undefined ? config.sequentialDownload : true;
                    createDirIfMissingCheck.checked = config.createDirIfMissing !== undefined ? config.createDirIfMissing : true;
                    
                    // Update state
                    state.installDir = installDirInput.value;
                    state.sequentialDownload = sequentialDownloadCheck.checked;
                    state.createDirIfMissing = createDirIfMissingCheck.checked;
                    updateInstallDirUI();
                    
                    if (config.packageSource) {
                        packageSource.value = config.packageSource;
                        // Trigger change event to update UI
                        const event = new Event('change');
                        packageSource.dispatchEvent(event);
                    }
                    
                    if (config.theme) {
                        setTheme(config.theme);
                    }
                }
            } catch (error) {
                console.error('Failed to load saved configuration:', error);
            }

            // Main download function
            async function downloadFiles() {
                if (state.downloadingFiles) {
                    showStatus('Download already in progress', 'info');
                    return;
                }
                
                if (state.downloadUrls.length === 0) {
                    showStatus('No files to download', 'error');
                    return;
                }
                
                state.downloadingFiles = true;
                
                try {
                    // Check if the File System Access API is supported
                    if (window.showDirectoryPicker) {
                        await downloadWithFileSystemAPI();
                    } else {
                        // Fallback to traditional download for browsers that don't support the File System API
                        await downloadWithTraditionalMethod();
                    }
                } catch (error) {
                    progressContainer.style.display = 'none';
                    showStatus(`Download error: ${error.message}`, 'error');
                    console.error('Download error:', error);
                } finally {
                    state.downloadingFiles = false;
                }
            }

            // Download using the File System Access API
            async function downloadWithFileSystemAPI() {
                // Create directory handle
                let dirHandle;
                try {
                    dirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'downloads'
                    });
                } catch (error) {
                    if (error.name === 'AbortError') {
                        state.downloadingFiles = false;
                        showStatus('Directory selection cancelled', 'info');
                        return;
                    }
                    throw error;
                }
                
                // Create installation directory if needed
                let targetDir = dirHandle;
                if (state.installDir && state.installDir !== '.') {
                    try {
                        targetDir = await dirHandle.getDirectoryHandle(state.installDir, { create: state.createDirIfMissing });
                    } catch (error) {
                        console.error(`Error accessing directory ${state.installDir}:`, error);
                        showStatus(`Error: Could not access '${state.installDir}' directory. Make sure it exists or enable 'Create directory if missing' in settings.`, 'error');
                        return;
                    }
                }
                
                // Show progress
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressText.textContent = 'Downloading files...';
                
                let successCount = 0;
                let failCount = 0;
                
                // Download files based on mode
                if (state.sequentialDownload) {
                    // Sequential download - more reliable
                    for (let i = 0; i < state.downloadUrls.length; i++) {
                        const pkg = state.downloadUrls[i];
                        const progress = Math.floor((i / state.downloadUrls.length) * 100);
                        
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `Downloading ${pkg.filename} (${i + 1}/${state.downloadUrls.length})`;
                        
                        try {
                            await downloadFileToDirectory(targetDir, pkg);
                            successCount++;
                            
                            // Update status in the table
                            updateDownloadStatus(pkg.name.toLowerCase(), true);
                        } catch (error) {
                            failCount++;
                            console.error(`Error downloading ${pkg.filename}:`, error);
                            
                            // Update status in the table
                            updateDownloadStatus(pkg.name.toLowerCase(), false);
                        }
                    }
                } else {
                    // Parallel download - faster but may be less reliable
                    const promises = [];
                    for (const pkg of state.downloadUrls) {
                        promises.push(
                            downloadFileToDirectory(targetDir, pkg)
                                .then(() => {
                                    successCount++;
                                    updateDownloadStatus(pkg.name.toLowerCase(), true);
                                })
                                .catch(error => {
                                    failCount++;
                                    console.error(`Error downloading ${pkg.filename}:`, error);
                                    updateDownloadStatus(pkg.name.toLowerCase(), false);
                                })
                        );
                    }
                    
                    // Show progress during parallel download
                    const updateInterval = setInterval(() => {
                        const progress = Math.floor(((successCount + failCount) / state.downloadUrls.length) * 100);
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `Downloaded ${successCount + failCount} of ${state.downloadUrls.length} files...`;
                        
                        if (successCount + failCount >= state.downloadUrls.length) {
                            clearInterval(updateInterval);
                        }
                    }, 100);
                    
                    // Wait for all downloads
                    await Promise.all(promises);
                    clearInterval(updateInterval);
                }
                
                // Set final progress
                progressBar.style.width = '100%';
                
                // Hide progress
                progressContainer.style.display = 'none';
                
                // Show result
                if (failCount === 0) {
                    showStatus(`Successfully downloaded ${successCount} files to '${state.installDir}' directory`, 'success');
                } else {
                    showStatus(`Downloaded ${successCount} files, ${failCount} failed. Check the console for details.`, 'warning');
                }
            }

            // Traditional download method using anchor tags (for browsers without File System Access API)
            async function downloadWithTraditionalMethod() {
                // Show progress
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressText.textContent = 'Preparing files for download...';
                
                showStatus('Your browser doesn\'t support the File System Access API. Files will be downloaded individually to your default download location.', 'info');
                
                let successCount = 0;
                let failCount = 0;
                
                // Create a container for the download links
                const downloadContainer = document.createElement('div');
                downloadContainer.style.display = 'none';
                document.body.appendChild(downloadContainer);
                
                if (state.sequentialDownload) {
                    // Sequential download
                    for (let i = 0; i < state.downloadUrls.length; i++) {
                        const pkg = state.downloadUrls[i];
                        const progress = Math.floor((i / state.downloadUrls.length) * 100);
                        
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `Downloading ${pkg.filename} (${i + 1}/${state.downloadUrls.length})`;
                        
                        try {
                            await downloadFileWithAnchor(pkg, downloadContainer);
                            successCount++;
                            updateDownloadStatus(pkg.name.toLowerCase(), true);
                            
                            // Add a small delay between downloads
                            await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (error) {
                            failCount++;
                            console.error(`Error preparing download for ${pkg.filename}:`, error);
                            updateDownloadStatus(pkg.name.toLowerCase(), false);
                        }
                    }
                } else {
                    // For parallel downloads, we'll use a slight stagger to avoid overwhelming the browser
                    const delay = 200; // 200ms delay between starting each download
                    
                    for (let i = 0; i < state.downloadUrls.length; i++) {
                        const pkg = state.downloadUrls[i];
                        
                        // Use setTimeout to stagger the downloads
                        setTimeout(() => {
                            downloadFileWithAnchor(pkg, downloadContainer)
                                .then(() => {
                                    successCount++;
                                    updateDownloadStatus(pkg.name.toLowerCase(), true);
                                    
                                    const progress = Math.floor(((successCount + failCount) / state.downloadUrls.length) * 100);
                                    progressBar.style.width = `${progress}%`;
                                    progressText.textContent = `Downloaded ${successCount + failCount} of ${state.downloadUrls.length} files...`;
                                })
                                .catch(error => {
                                    failCount++;
                                    console.error(`Error preparing download for ${pkg.filename}:`, error);
                                    updateDownloadStatus(pkg.name.toLowerCase(), false);
                                    
                                    const progress = Math.floor(((successCount + failCount) / state.downloadUrls.length) * 100);
                                    progressBar.style.width = `${progress}%`;
                                    progressText.textContent = `Downloaded ${successCount + failCount} of ${state.downloadUrls.length} files...`;
                                });
                        }, i * delay);
                    }
                    
                    // Wait for all downloads to complete (approximately)
                    await new Promise(resolve => setTimeout(resolve, state.downloadUrls.length * delay + 2000));
                }
                
                // Remove the download container
                document.body.removeChild(downloadContainer);
                
                // Set final progress
                progressBar.style.width = '100%';
                
                // Hide progress
                progressContainer.style.display = 'none';
                
                // Show result
                if (failCount === 0) {
                    showStatus(`Initiated download for ${successCount} files. Check your downloads folder.`, 'success');
                } else {
                    showStatus(`Initiated download for ${successCount} files, ${failCount} failed. Check the console for details.`, 'warning');
                }
                
                // Show additional instructions for manual installation
                const installDirMessage = document.createElement('div');
                installDirMessage.className = 'info-box';
                installDirMessage.innerHTML = `
                    <p><strong>After downloading:</strong></p>
                    <ol>
                        <li>Create a directory named "${state.installDir}" in your project</li>
                        <li>Move all downloaded wheel files to this directory</li>
                        <li>Run the installation command in your terminal:</li>
                    </ol>
                    <pre>pip install --no-index --find-links=./${state.installDir} ${state.packageName}</pre>
                `;
                
                downloadLinks.appendChild(installDirMessage);
            }

            // Update download status in the table
            function updateDownloadStatus(packageName, success) {
                const statusEl = document.getElementById(`download-status-${packageName}`);
                if (statusEl) {
                    statusEl.textContent = success ? '✓' : '✗';
                    statusEl.className = `download-status ${success ? 'success' : 'error'}`;
                    statusEl.style.display = 'inline';
                }
            }

            // Download a single file using File System Access API
            async function downloadFileToDirectory(dirHandle, pkg) {
                try {
                    // Fetch the file
                    const response = await fetch(pkg.url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const blob = await response.blob();
                    
                    // Create file in the directory
                    const fileHandle = await dirHandle.getFileHandle(pkg.filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    return true;
                } catch (error) {
                    console.error(`Error downloading ${pkg.filename}:`, error);
                    throw error;
                }
            }
            
            // Download a file using an anchor tag (traditional method)
            async function downloadFileWithAnchor(pkg, container) {
                return new Promise((resolve, reject) => {
                    // Fetch the file
                    fetch(pkg.url)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            return response.blob();
                        })
                        .then(blob => {
                            // Create a URL for the blob
                            const url = URL.createObjectURL(blob);
                            
                            // Create an anchor element
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = pkg.filename;
                            container.appendChild(a);
                            
                            // Click the anchor to trigger download
                            a.click();
                            
                            // Clean up
                            setTimeout(() => {
                                container.removeChild(a);
                                URL.revokeObjectURL(url);
                                resolve();
                            }, 100);
                        })
                        .catch(error => {
                            reject(error);
                        });
                });
            }

            // Theme functions
            function initTheme() {
                // Check for saved theme preference or use system preference
                const savedTheme = localStorage.getItem('pyWheelManagerTheme');
                if (savedTheme) {
                    setTheme(savedTheme);
                } else {
                    // Check system preference
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        setTheme('dark');
                    } else {
                        setTheme('light');
                    }
                }
            }
            
            function toggleTheme() {
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                setTheme(newTheme);
                localStorage.setItem('pyWheelManagerTheme', newTheme);
            }
            
            function setTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                themeToggleBtn.textContent = theme === 'light' ? '🌙' : '☀️';
            }

            // Update installation command based on installation path
            function updateInstallationCommand() {
                if (state.packageName) {
                    const path = state.installDir.trim() || 'wheels';
                    installCommand.textContent = `pip install --no-index --find-links=./${path} ${state.packageName}`;
                }
            }

            // Platform and architecture detection
            function detectPlatform() {
                const ua = navigator.userAgent.toLowerCase();
                if (ua.includes('windows')) return 'win';
                if (ua.includes('mac os') || ua.includes('macos') || ua.includes('darwin')) return 'macosx';
                if (ua.includes('linux')) return 'linux';
                return 'win'; // Default to Windows
            }
            
            function detectArchitecture() {
                const ua = navigator.userAgent.toLowerCase();
                
                // Check for Windows architecture
                if (ua.includes('windows')) {
                    if (ua.includes('win64') || ua.includes('wow64') || ua.includes('x64')) {
                        return 'x86_64';
                    }
                    if (ua.includes('arm64') || ua.includes('aarch64')) {
                        return 'arm64';
                    }
                    return 'i686'; // 32-bit Windows
                }
                
                // Check for Mac architecture
                if (ua.includes('mac os') || ua.includes('macos') || ua.includes('darwin')) {
                    if (ua.includes('arm64') || ua.includes('apple silicon')) {
                        return 'arm64';
                    }
                    return 'x86_64'; // Intel Mac
                }
                
                // Check for Linux architecture
                if (ua.includes('linux')) {
                    if (ua.includes('arm64') || ua.includes('aarch64')) {
                        return 'arm64';
                    }
                    if (ua.includes('ppc64le')) {
                        return 'ppc64le';
                    }
                    if (ua.includes('s390x')) {
                        return 's390x';
                    }
                    if (ua.includes('x86_64') || ua.includes('x64')) {
                        return 'x86_64';
                    }
                    return 'i686'; // 32-bit Linux
                }
                
                // Additional detection using navigator.platform (deprecated but still useful)
                const platform = navigator.platform;
                if (platform) {
                    if (platform.includes('Win64') || platform.includes('x64')) return 'x86_64';
                    if (platform.includes('Win32')) return 'i686';
                    if (platform.includes('MacIntel')) return 'x86_64';
                    if (platform.includes('Linux x86_64')) return 'x86_64';
                    if (platform.includes('Linux i686')) return 'i686';
                }
                
                // Use CPU cores as a hint for 32 vs 64 bit
                if (navigator.hardwareConcurrency > 4) {
                    return 'x86_64'; // Likely 64-bit if many cores
                }
                
                return 'x86_64'; // Default to x86_64
            }

            // Process the dependency queue in batches (non-recursive approach)
            async function processRemainingDependencies() {
                // Process in batches to avoid UI freezing
                const batchSize = 10;
                
                while (state.pendingDependencies.length > 0 && !state.cancelled) {
                    // Get next batch
                    const batch = state.pendingDependencies.splice(0, batchSize);
                    
                    // Process batch in parallel
                    const promises = batch.map(dep => 
                        analysePackage(dep.name, dep.parent, dep.depth)
                    );
                    
                    // Wait for batch completion
                    await Promise.all(promises);
                    
                    // Update progress
                    updateProgress();
                    
                    // Small delay to allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 0));
                    
                    // Check for cancellation
                    if (state.cancelled) {
                        break;
                    }
                }
                
                return state.processed.size;
            }
            
            // Main functions
            async function analysePackage(packageName, parent = null, depth = 0, retryCount = 0) {
                if (state.cancelled) {
                    return;
                }
                
                // Normalize package name for consistent lookup
                const normalizedName = packageName.toLowerCase().trim();
                
                // Check if we've already processed this package
                if (state.processed.has(normalizedName)) {
                    return;
                }
                
                // Check for circular dependencies (package being processed)
                if (state.processing.has(normalizedName)) {
                    console.log(`Circular dependency detected: ${packageName}`);
                    return;
                }
                
                // Check for max depth
                if (depth > state.maxDependencyDepth) {
                    console.log(`Reached max depth (${state.maxDependencyDepth}) for ${packageName}`);
                    return;
                }
                
                // Check for max package count
                if (state.processed.size + state.processing.size >= state.maxPackageCount) {
                    console.log(`Reached max package count (${state.maxPackageCount})`);
                    showStatus(`Analysis stopped: reached maximum package count (${state.maxPackageCount})`, 'info');
                    state.cancelled = true;
                    return;
                }
                
                // Mark package as being processed to prevent cycles
                state.processing.add(normalizedName);
                state.currentDepth = Math.max(state.currentDepth, depth);
                
                try {
                    // Fetch package info from PyPI
                    const packageInfo = await getPackageInfo(packageName);
                    
                    // Handle package not found or network error
                    if (!packageInfo) {
                        // For root package, this is a critical error
                        if (depth === 0) {
                            state.cancelled = true;
                            showStatus(`Package "${packageName}" not found on PyPI or network error`, 'error');
                            throw new Error(`Package "${packageName}" not found on PyPI`);
                        }
                        
                        // For non-root packages, log warning and try to continue
                        console.warn(`Could not fetch info for dependency: ${packageName}`);
                        state.processing.delete(normalizedName);
                        return;
                    }
                    
                    // Check Python version compatibility
                    if (!isPythonVersionCompatible(packageInfo)) {
                        // For the root package, we should stop the analysis
                        if (depth === 0) {
                            state.cancelled = true;
                            showStatus(`Package "${packageName}" is not compatible with Python ${state.pythonVersion}`, 'error');
                            throw new Error(`Package "${packageName}" is not compatible with Python ${state.pythonVersion}`);
                        }
                        
                        // For dependencies, we can skip incompatible packages
                        console.warn(`Skipping incompatible dependency: ${packageName} (requires different Python version)`);
                        state.processing.delete(normalizedName);
                        return;
                    }
                    
                    // For all packages, apply reasonable limits to avoid browser freezing
                    // Only apply once at the root level
                    if (depth === 0) {
                        // Enforce safer defaults regardless of what was set in the UI
                        const originalMaxPackageCount = state.maxPackageCount;
                        const originalMaxDepth = state.maxDependencyDepth;
                        
                        // Hard cap of 100 packages and depth 4 for all package analysis
                        const maxSafePackages = 100;
                        const maxSafeDepth = 4;
                        
                        // Apply the caps if user settings are higher
                        if (state.maxPackageCount > maxSafePackages) {
                            state.maxPackageCount = maxSafePackages;
                        }
                        if (state.maxDependencyDepth > maxSafeDepth) {
                            state.maxDependencyDepth = maxSafeDepth;
                        }
                        
                        // Only show info message if we had to adjust the limits
                        if (originalMaxPackageCount > maxSafePackages || originalMaxDepth > maxSafeDepth) {
                            showStatus(`For stability, limiting dependency analysis to ${state.maxPackageCount} packages and depth ${state.maxDependencyDepth}.`, 'info');
                            console.log(`Applied safe limits: max ${maxSafePackages} packages, max depth ${maxSafeDepth}`);
                        }
                    }
                    
                    // Get package dependencies with improved parsing
                    const dependencies = getPackageDependencies(packageInfo);
                    
                    // Get wheel URL with compatibility check
                    const [wheelUrl, wheelFilename, isCompatible] = getBestWheelUrl(packageInfo);
                    
                    // If root package has no compatible wheels, stop analysis
                    if (depth === 0 && !isCompatible) {
                        state.cancelled = true;
                        showStatus(`No compatible wheel found for "${packageName}" with Python ${state.pythonVersion} on ${state.platform} ${state.architecture}`, 'error');
                        throw new Error(`No compatible wheel found for "${packageName}"`);
                    }
                    
                    // Store in state with additional metadata
                    state.dependencies.set(normalizedName, {
                        name: packageName,  // Preserve original casing
                        version: packageInfo.info.version,
                        dependencies: dependencies,
                        wheelUrl,
                        wheelFilename,
                        parent,
                        depth,
                        summary: packageInfo.info.summary || '',
                        hasWheel: !!wheelUrl,
                        processedAt: new Date().toISOString()
                    });
                    
                    // Mark as processed and remove from in-progress
                    state.processed.add(normalizedName);
                    state.processing.delete(normalizedName);
                    
                    // Update progress
                    updateProgress();
                    
                    // Use an iterative approach instead of recursive to avoid stack overflow
                    // Add dependencies to a queue to be processed separately
                    if (depth < state.maxDependencyDepth) {
                        const allDependencies = [...dependencies];
                        
                        // Instead of recursively calling analysePackage, add to pending queue
                        for (const dep of allDependencies) {
                            // Skip if we've hit max package count
                            if (state.processed.size + state.processing.size >= state.maxPackageCount) {
                                console.log(`Skipping remaining dependencies - reached max package count (${state.maxPackageCount})`);
                                break;
                            }
                            
                            // Add to global dependencies list with parent info, to be processed later
                            const normalizedDep = dep.toLowerCase().trim();
                            if (!state.processed.has(normalizedDep) && !state.processing.has(normalizedDep)) {
                                state.pendingDependencies.push({
                                    name: dep,
                                    parent: normalizedName,
                                    depth: depth + 1
                                });
                            }
                        }
                    }
                    
                } catch (error) {
                    // Handle specific error types and retry logic
                    if (error.name === 'TypeError' || error.name === 'SyntaxError') {
                        // These might be temporary parsing issues - could retry
                        if (retryCount < 2) {
                            console.log(`Retrying ${packageName} after error: ${error.message}`);
                            state.processing.delete(normalizedName);
                            return analysePackage(packageName, parent, depth, retryCount + 1);
                        }
                    }
                    
                    // Clean up processing state
                    state.processing.delete(normalizedName);
                    console.error(`Error processing ${packageName}:`, error);
                    
                    // If it's the root package, we should stop the analysis
                    if (depth === 0) {
                        state.cancelled = true;
                        throw error;
                    }
                }
            }

            function updateProgress() {
                if (state.cancelled) return;
                
                const totalPackages = state.processed.size + state.processing.size;
                const completedPackages = state.processed.size;
                
                // Calculate progress percentage based on processed packages
                let progress = Math.min(100, (completedPackages / Math.max(1, totalPackages)) * 100);
                
                // Ensure progress never goes backward
                progress = Math.max(progress, parseFloat(progressBar.style.width) || 0);
                
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `Analysed ${completedPackages} packages (depth: ${state.currentDepth}/${state.maxDependencyDepth})`;
            }

            async function getPackageInfo(packageName) {
                const url = `https://pypi.org/pypi/${packageName}/json`;
                try {
                    const response = await fetch(url);
                    if (response.status === 200) {
                        return response.json();
                    }
                    
                    // Only show error for the root package
                    if (state.processed.size === 0 && state.processing.size <= 1) {
                        showStatus(`Package "${packageName}" not found on PyPI`, 'error');
                    }
                    return null;
                } catch (error) {
                    // Only show error for the root package
                    if (state.processed.size === 0 && state.processing.size <= 1) {
                        showStatus(`Network error: ${error.message}`, 'error');
                    }
                    return null;
                }
            }

            function isPythonVersionCompatible(packageInfo) {
                if (!packageInfo || !packageInfo.info) {
                    return true; // Default to compatible if no info
                }
                
                // Check requires_python field
                const requiresPython = packageInfo.info.requires_python;
                if (!requiresPython) {
                    return true; // No Python version requirement
                }
                
                // Parse Python version requirements
                try {
                    const currentVersion = state.pythonVersion;
                    let compatibilityDetail = '';
                    let isCompatible = true;
                    
                    // Enhanced version comparison logic - properly handle multiple conditions
                    // e.g. ">=3.7, <3.12", ">3.8, !=3.9.0"
                    const requirements = requiresPython.split(',').map(r => r.trim());
                    
                    for (const req of requirements) {
                        // Skip empty requirements
                        if (!req) continue;
                        
                        // Handle different operators
                        if (req.startsWith('>=')) {
                            const minVersion = req.substring(2).trim().split(/[\s)]/)[0];
                            if (compareVersions(currentVersion, minVersion) < 0) {
                                compatibilityDetail = `Package requires Python >= ${minVersion}, but using ${currentVersion}`;
                                isCompatible = false;
                                break;
                            }
                        } else if (req.startsWith('>')) {
                            const minVersion = req.substring(1).trim().split(/[\s)]/)[0];
                            if (compareVersions(currentVersion, minVersion) <= 0) {
                                compatibilityDetail = `Package requires Python > ${minVersion}, but using ${currentVersion}`;
                                isCompatible = false;
                                break;
                            }
                        } else if (req.startsWith('<=')) {
                            const maxVersion = req.substring(2).trim().split(/[\s)]/)[0];
                            if (compareVersions(currentVersion, maxVersion) > 0) {
                                compatibilityDetail = `Package requires Python <= ${maxVersion}, but using ${currentVersion}`;
                                isCompatible = false;
                                break;
                            }
                        } else if (req.startsWith('<')) {
                            const maxVersion = req.substring(1).trim().split(/[\s)]/)[0];
                            if (compareVersions(currentVersion, maxVersion) >= 0) {
                                compatibilityDetail = `Package requires Python < ${maxVersion}, but using ${currentVersion}`;
                                isCompatible = false;
                                break;
                            }
                        } else if (req.startsWith('==')) {
                            const exactVersion = req.substring(2).trim().split(/[\s)]/)[0];
                            if (compareVersions(currentVersion, exactVersion) !== 0) {
                                compatibilityDetail = `Package requires Python == ${exactVersion}, but using ${currentVersion}`;
                                isCompatible = false;
                                break;
                            }
                        } else if (req.startsWith('!=')) {
                            const excludedVersion = req.substring(2).trim().split(/[\s)]/)[0];
                            if (compareVersions(currentVersion, excludedVersion) === 0) {
                                compatibilityDetail = `Package excludes Python ${excludedVersion}, but using ${currentVersion}`;
                                isCompatible = false;
                                break;
                            }
                        }
                    }
                    
                    if (!isCompatible) {
                        console.log(compatibilityDetail);
                        
                        // For root package, display incompatibility immediately
                        if (packageInfo.info.name?.toLowerCase() === state.packageName.toLowerCase()) {
                            showStatus(compatibilityDetail, 'error');
                            state.pythonVersionCompatible = false;
                        }
                    }
                    
                    return isCompatible;
                } catch (error) {
                    console.warn(`Error parsing Python version requirement "${requiresPython}":`, error);
                    return true; // Default to compatible on parsing error
                }
            }

            function compareVersions(v1, v2) {
                // Convert versions to arrays of integers
                const v1Parts = v1.split('.').map(Number);
                const v2Parts = v2.split('.').map(Number);
                
                // Compare each part
                for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
                    const p1 = i < v1Parts.length ? v1Parts[i] : 0;
                    const p2 = i < v2Parts.length ? v2Parts[i] : 0;
                    
                    if (p1 < p2) return -1;
                    if (p1 > p2) return 1;
                }
                
                return 0; // Versions are equal
            }

            function getPackageDependencies(packageInfo) {
                if (!packageInfo || !packageInfo.info) {
                    return [];
                }
                
                const requiresDist = packageInfo.info.requires_dist || [];
                if (!requiresDist.length) {
                    return [];
                }
                
                const dependencies = [];
                
                for (const req of requiresDist) {
                    try {
                        // Parse the requirement string into components
                        const dependencyInfo = parseDependencyString(req);
                        
                        // Check if this is an environment marker dependency
                        if (dependencyInfo.marker) {
                            // Evaluate the environment marker against current settings
                            if (!evaluateEnvironmentMarker(dependencyInfo.marker)) {
                                // Skip dependencies that don't match our environment
                                continue;
                            }
                        }
                        
                        // Add dependency to the list if it's not already present
                        if (dependencyInfo.name && !dependencies.includes(dependencyInfo.name)) {
                            dependencies.push(dependencyInfo.name);
                        }
                    } catch (error) {
                        console.warn(`Error parsing dependency: ${req}`, error);
                        // Try a fallback simpler approach for this requirement
                        const match = req.match(/^([^<>=;\[]+)/);
                        if (match) {
                            const simpleName = match[1].trim();
                            if (simpleName && !dependencies.includes(simpleName)) {
                                dependencies.push(simpleName);
                            }
                        }
                    }
                }
                
                return dependencies;
            }
            
            // Parse a dependency string into structured components
            function parseDependencyString(reqString) {
                // Default structure
                const result = {
                    name: null,
                    specifier: null,
                    marker: null,
                    extras: []
                };
                
                try {
                    // Split environment marker
                    let [requirement, envMarker] = reqString.split(';').map(s => s.trim());
                    result.marker = envMarker;
                    
                    // Extract extras if any
                    const extrasMatch = requirement.match(/^([^\[]+)\[([^\]]+)\]/);
                    if (extrasMatch) {
                        result.name = extrasMatch[1].trim();
                        result.extras = extrasMatch[2].split(',').map(e => e.trim());
                        // Reconstruct the base requirement without extras for version parsing
                        requirement = result.name;
                    } else {
                        // Extract package name (everything before any version specifier)
                        const nameMatch = requirement.match(/^([^<>=!~]+)/);
                        if (nameMatch) {
                            result.name = nameMatch[1].trim();
                        }
                    }
                    
                    // Extract version specifier(s)
                    const versionMatch = requirement.match(/([<>=!~]+\s*[0-9a-zA-Z.*]+)(?:\s*,\s*([<>=!~]+\s*[0-9a-zA-Z.*]+))*/);
                    if (versionMatch) {
                        result.specifier = versionMatch[0].trim();
                    }
                    
                } catch (error) {
                    console.warn(`Error parsing requirement: ${reqString}`, error);
                }
                
                return result;
            }
            
            // Evaluate an environment marker against current environment
            function evaluateEnvironmentMarker(marker) {
                if (!marker) return true;
                
                try {
                    // Simple cases - just check if Python version is mentioned and matches
                    if (marker.includes('python_version')) {
                        const pyVersion = state.pythonVersion;
                        
                        // Handle various Python version comparisons
                        if (marker.includes('>=') && marker.includes(pyVersion)) {
                            return true;
                        }
                        if (marker.includes('>') && !marker.includes('>=') && marker.includes(pyVersion)) {
                            return false; // Strict greater than
                        }
                        if (marker.includes('<=') && marker.includes(pyVersion)) {
                            return true;
                        }
                        if (marker.includes('<') && !marker.includes('<=') && marker.includes(pyVersion)) {
                            return true; // Strict less than
                        }
                        if (marker.includes('==') && marker.includes(pyVersion)) {
                            return true;
                        }
                        if (marker.includes('!=') && marker.includes(pyVersion)) {
                            return false;
                        }
                        
                        // Check for specific platform or OS markers
                        if (marker.includes('sys_platform') || marker.includes('platform_system')) {
                            if (marker.includes('win') && state.platform === 'win') {
                                return true;
                            }
                            if ((marker.includes('linux') || marker.includes('Linux')) && state.platform === 'linux') {
                                return true;
                            }
                            if ((marker.includes('darwin') || marker.includes('Darwin') || marker.includes('macos')) && state.platform === 'macosx') {
                                return true;
                            }
                        }
                        
                        // More advanced checks would go here
                        
                        // Default for complex marker - include the dependency to be safe
                        return true;
                    }
                    
                    // Handle 'extra' markers - exclude for now
                    if (marker.includes('extra ==')) {
                        return false;
                    }
                    
                    // Default case - if we're not sure, include the dependency
                    return true;
                } catch (error) {
                    console.warn(`Error evaluating marker: ${marker}`, error);
                    return true; // Default to true if parsing fails
                }
            }

            function getBestWheelUrl(packageInfo) {
                if (!packageInfo || !packageInfo.releases) {
                    return [null, null, false];
                }
                
                const latestVersion = packageInfo.info.version;
                const releases = packageInfo.releases[latestVersion];
                
                if (!releases || releases.length === 0) {
                    return [null, null, false];
                }
                
                // Filter for wheel files
                const wheelFiles = releases.filter(r => r.packagetype === 'bdist_wheel');
                
                if (!wheelFiles.length) {
                    // Fall back to source distribution
                    const sourceFiles = releases.filter(r => r.packagetype === 'sdist');
                    if (sourceFiles.length) {
                        return [sourceFiles[0].url, sourceFiles[0].filename, true];
                    }
                    return [null, null, false];
                }
                
                const pythonTag = `cp${state.pythonVersion.replace('.', '')}`;
                const platformTag = state.platform;
                const archTag = state.architecture;
                
                // Find the best matching wheel
                let bestWheel = null;
                let bestScore = -1;
                
                for (const wheel of wheelFiles) {
                    const filename = wheel.filename;
                    let score = 0;
                    
                    // Universal wheels
                    if (filename.includes('py3-none-any')) {
                        score = 100;
                    } else if (filename.includes('py2.py3-none-any')) {
                        score = 90;
                    } else {
                        // Python version match
                        if (filename.includes(pythonTag)) {
                            score += 50;
                            
                            // Platform match
                            if (filename.toLowerCase().includes(platformTag.toLowerCase())) {
                                score += 30;
                                
                                // Architecture match
                                if (filename.toLowerCase().includes(archTag.toLowerCase())) {
                                    score += 20;
                                }
                            } else if (filename.includes('none-any')) {
                                score += 25; // Python version match, any platform
                            }
                        }
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestWheel = wheel;
                    }
                }
                
                if (bestWheel) {
                    return [bestWheel.url, bestWheel.filename, true];
                }
                
                // If no compatible wheel, return the source distribution
                const sourceFiles = releases.filter(r => r.packagetype === 'sdist');
                if (sourceFiles.length) {
                    return [sourceFiles[0].url, sourceFiles[0].filename, true];
                }
                
                return [null, null, false];
            }

            function displayResults() {
                // Build dependency tree
                dependencyTree.innerHTML = '';
                buildDependencyTree(state.packageName.toLowerCase(), dependencyTree);
                
                // Build download links
                downloadLinks.innerHTML = '';
                const table = document.createElement('table');
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Package</th>
                            <th>Version</th>
                            <th>Filename</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="downloadTableBody"></tbody>
                `;
                
                downloadLinks.appendChild(table);
                const tbody = document.getElementById('downloadTableBody');
                
                // Collect all download URLs
                state.downloadUrls = [];
                for (const [name, pkg] of state.dependencies) {
                    if (pkg.wheelUrl && pkg.wheelFilename) {
                        state.downloadUrls.push({
                            name: pkg.name,
                            version: pkg.version,
                            url: pkg.wheelUrl,
                            filename: pkg.wheelFilename
                        });
                        
                        const tr = document.createElement('tr');
                        tr.innerHTML = `
                            <td>${pkg.name}</td>
                            <td>${pkg.version}</td>
                            <td>${pkg.wheelFilename}</td>
                            <td>
                                <span id="download-status-${name}" class="download-status"></span>
                            </td>
                        `;
                        tbody.appendChild(tr);
                    }
                }
                
                // Update package count
                totalPackages.textContent = state.processed.size;
                
                // Update installation command and directory
                updateInstallDirUI();
                
                // Show download button if we have files to download
                if (state.downloadUrls.length > 0) {
                    downloadBtn.style.display = 'inline-block';
                } else {
                    downloadBtn.style.display = 'none';
                }
            }

            function buildDependencyTree(rootPackageName, container) {
                // Iterative approach to avoid recursion
                // We'll use a queue of tasks to process
                const queue = [{
                    packageName: rootPackageName,
                    container: container,
                    isRoot: true,
                    level: 0
                }];
                
                // Track processed nodes to avoid circular references
                const processedInTree = new Set();
                
                // Process the queue until empty
                while (queue.length > 0) {
                    const { packageName, container, isRoot, level } = queue.shift();
                    
                    // Skip if already in the tree or too deep
                    if (processedInTree.has(packageName) || level > 5) {
                        continue;
                    }
                    
                    // Mark as processed in the tree
                    processedInTree.add(packageName);
                    
                    const pkg = state.dependencies.get(packageName);
                    if (!pkg) continue;
                    
                    // Create item
                    const item = document.createElement('div');
                    item.className = isRoot ? 'tree-item-root' : 'tree-item';
                    
                    const hasWheel = pkg.wheelUrl && pkg.wheelFilename;
                    const badgeClass = hasWheel ? 'badge-success' : 'badge-warning';
                    const badgeText = hasWheel ? 'Wheel' : 'Source';
                    
                    item.innerHTML = `
                        <div>
                            ${pkg.name} <span class="package-version">v${pkg.version}</span>
                            <span class="badge ${badgeClass}">${badgeText}</span>
                        </div>
                    `;
                    
                    container.appendChild(item);
                    
                    // Create subcontainer for dependencies
                    if (pkg.dependencies && pkg.dependencies.length > 0) {
                        const subContainer = document.createElement('div');
                        subContainer.style.marginLeft = '1.5rem';
                        container.appendChild(subContainer);
                        
                        // Add dependencies to queue
                        for (const dep of pkg.dependencies) {
                            queue.push({
                                packageName: dep.toLowerCase(),
                                container: subContainer,
                                isRoot: false,
                                level: level + 1
                            });
                        }
                    }
                }
            }

            function showStatus(message, type = 'info') {
                statusEl.textContent = message;
                statusEl.className = `status status-${type}`;
                statusEl.style.display = 'block';
                
                // Hide after 5 seconds
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }

            // Initialize with platform and architecture detection
            const platform = detectPlatform();
            const architecture = detectArchitecture();
            document.getElementById('platform').value = platform;
            document.getElementById('architecture').value = architecture;
            
            // Update install directory UI on load
            updateInstallDirUI();
            
            // Save theme changes
            themeToggleBtn.addEventListener('click', saveCurrentConfig);
            
            // Fetch popular packages for autocomplete
            async function fetchPopularPackages() {
                try {
                    const response = await fetch('https://pypi.org/simple/');
                    if (response.ok) {
                        const text = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/html');
                        const links = doc.querySelectorAll('a');
                        const packages = Array.from(links)
                            .map(link => link.textContent.trim())
                            .filter(pkg => pkg);
                        
                        if (packages.length > 100) {
                            // Get some randomly selected packages to add to the popular list
                            const randomPackages = [];
                            for (let i = 0; i < 50; i++) {
                                const randomIndex = Math.floor(Math.random() * packages.length);
                                randomPackages.push(packages[randomIndex]);
                            }
                            
                            state.popularPackages = [...new Set([...state.popularPackages, ...randomPackages])];
                        }
                    }
                } catch (error) {
                    console.error('Failed to fetch popular packages:', error);
                }
            }
            
            // Try to fetch popular packages in background
            fetchPopularPackages();
        });
    </script>
</body>
</html>